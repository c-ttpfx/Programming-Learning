# 类的生命周期

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称 为连接（Linking）。

![image-20230921154106541](https://raw.githubusercontent.com/c-ttpfx/markdown-image/main/typora-img/image-20230921154106541.png)

加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始（是开始不是完成），而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始， 这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。

# 加载

在加载阶段，Java虚拟机需要完成以下三件事情： 

1.  通过一个类的全限定名来获取定义此类的二进制字节流。 

2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 

3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

不同的虚拟机实现细节有所不同

# 验证

验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚 拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

验证阶段大致上会完成下面四个阶段的检验动作：

* **文件格式验证**：首先验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，例如是否以魔数0xCAFEBABE开头。主、次版本号是否在当前Java虚拟机接受范围之内。等

* **元数据验证**：第二阶段是对字节码描述的信息进行语义分析、校验，以保证其描述的信息符合《Java语言规范》的要求，例如这个类是否有父类，这个类的父类是否继承了不允许被继承的类，如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法等等
* **字节码验证**：第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定序语义是合法的、符合逻辑的。例如保证任何跳转指令都不会跳转到方法体以外的字节码指令上，例如不会出现类似于“在操作 栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况等等
* **符号引用验证**：最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段—解析阶段中发生。通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。例如符号引用中通过字符串描述的全限定名是否能找到对应的类，在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段等等

# 准备

准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，这时候进行内存分配的仅包括类变量，而不包括实例变量。

类变量在准备阶段之后的默认值如下

![image-20230921163134041](https://raw.githubusercontent.com/c-ttpfx/markdown-image/main/typora-img/image-20230921163134041.png)

```java
public static int value = 123
```

对于上面代码，在准备阶段之后value的值为0，而不是123，把value赋值为123指令存放于类构造器&lt;client&gt;()方法之中，要到类的初始化阶段才会被执行。

如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值

```java
public static final int value = 123;
```

上面使用了final修饰value，那么value在准备阶段之后就是123了，不会使用默认值。

# 解析

解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，这句话的具体解释如下

1. **符号引用（Symbolic Reference）**：在Java源代码中，类和成员（字段、方法）的引用通常以符号引用的形式存在。这些引用是一种符号性的标识，指向了目标类或成员的名字、描述符等信息。例如，`String`类型的字段引用可能是 `Ljava/lang/String;` 这样的描述。
2. **直接引用（Direct Reference）**：与符号引用不同，直接引用是一个指向内存位置的指针或句柄，它可以直接用于访问目标类或成员的内存地址。直接引用是实际的内存指针或句柄，可以直接执行实际操作。
3. **解析（Resolution）**：解析是将符号引用转化为直接引用的过程。在Java类加载过程中，虚拟机需要知道如何定位并访问目标类或成员，因此需要将符号引用解析为直接引用。这通常涉及到查找目标类的内存地址、方法的内存偏移量等信息。
4. **可选性**：解析阶段在类加载过程中是可选的。这意味着不是每个类加载过程都需要执行解析。解析通常在需要使用某个类或成员的时候才会进行，而且某些情况下，虚拟机可能会跳过解析，直接使用符号引用来访问目标。

总结来说，解析是将类或成员的符号引用转化为直接引用的过程，但它并不一定在每次加载类时都执行。虚拟机可能会延迟解析，只在需要的时候执行，以提高性能和节省资源。这个过程有助于虚拟机在运行时准确访问类或成员的内存位置。

举一个简单的例子如下

```java
public class MathUtil {
    public static int add(int a, int b) {
        return a + b;
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        int result = MathUtil.add(5, 3);
        System.out.println("Result: " + result);
    }
}
```

在Test类中，`MathUtil.add(5, 3)` 是一个符号引用，它指向了 `MathUtil` 类和 `add` 方法，但它并没有直接指向方法的内存地址或偏移量。

解析阶段会将这个符号引用转化为直接引用，以便能够执行实际的方法调用。这个过程涉及查找 `MathUtil` 类的内存地址，并获取 `add` 方法的内存偏移量。一旦解析完成，就可以直接调用 `add` 方法的内存地址

# 初始化

简单来说初始化阶段就是执行类构造器&lt;client()&gt;方法的过程。

&lt;client()&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问 到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问

```java
public class Test {
    static {
        i = 0; // 给变量复制可以正常编译通过
        System.out.print(i); // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

&lt;client()&gt;()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;client()&gt;()方法

Java虚拟机必须保证一个类的&lt;client()&gt;()方法在多线程环境中被正确地加锁同步，如果多个线程同 时去初始化一个类，那么只会有其中一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行完毕&lt;client()&gt;()方法。

《Java虚拟机规范》 严格规定了**有且只有六种情况**必须立即对类进行“初始化”

1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。
2. 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。
3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
5. 如果一个java.lang.invoke.MethodHandle实例最后的解 析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6. 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

# 简要概括


类加载过程分为以下几个简单的阶段：

1. **加载（Loading）**：从磁盘或网络加载类的字节码到内存，形成类的结构。
2. **验证（Verification）**：确保加载的字节码合法且不包含安全风险。
3. **准备（Preparation）**：为类的静态变量分配内存并初始化为默认值。
4. **解析（Resolution，可选）**：将符号引用转化为直接引用，以便正确访问类和成员。
5. **初始化（Initialization）**：执行类的初始化代码，包括静态初始化块和静态字段的赋值。

这些阶段确保了类在运行时能够被正确加载和使用。其中，解析是可选的，其他阶段通常都会执行。