# 根节点枚举

在可达性分析算法中，由于GC Roots众多，所以在从GC Roots集合中进行引用链查找时会耗费大量时间。

迄今为止，**所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的**，因此毫无疑问根节点 枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。

现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行。（这里“一致性”的意思是整个枚举期间执行子系统 看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化 的情况）

在HotSpot里，使用一组称为OopMap的数据结构来存储了对象的地址。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举

# 安全点

可能导致引用关系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。

所以出现了安全点的概念，安全点就类似于存档点一样，当线程执行到安全点的时候就进行一下存档操作，也就是更新OopMap里面的内容。由于安全点的出现，也就说明了垃圾收集不是任何时候都能够进行的，线程必须要到达的安全点后才能暂停开始垃圾收集操作。

对于垃圾收集要求所有线程都要执行到安全点才能够暂停，主要有两种方案可以选择

* **抢先式中断**：抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。
* **主动式中断**：这种方式就相当于设置一个标志位来表示是否进行垃圾收集，让所有的线程去轮询这个标志位，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。（由于轮询操作在代码中会频繁出现，这要求它必须足够高效。HotSpot使用内存保护陷阱的方式， 把轮询操作精简至只有一条汇编指令的程度。）

# 安全区域

安全点使用中断的方式来进行解决，那么这样就会出现问题，如果用户线程处于Sleep状态或者Blocked状态并不会响应中断，这个时候该线程并不会处于安全点，虚拟机也不可能持续等待线程重新被激活分配处理器时间。对于这种情况，就可以使用安全区域进行解决。

安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。

当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。

# 记忆集与卡表

由于存在跨代引用的问题，所以垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围。

**记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。**

在记忆集中我们可以选择记录的信息，如下

* 字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。 

* 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。 

* 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

在第三种卡精度所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集，这个是目前最常见的一种实现方式。

卡表最简单的形式可以只是一个字节数组（之所以使用byte数组而不是bit数组主要是速度上的考量，现代计算机硬件都是最小按字节寻址的），而HotSpot虚拟机确实也是这样做的。如下

```c
CARD_TABLE [this address >> 9] = 0;
```

字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page）。一般来说，卡页大小都是以2的N次幂的字节数。

![image-20230908151710241](https://raw.githubusercontent.com/c-ttpfx/markdown-image/main/typora-img/image-20230908151710241.png)

一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。

# 写屏障

上面的记忆集只缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维 护的问题，例如它们何时变脏、谁来把它们变脏等。

在HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态的。**写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面**，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的 前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作**写前屏障（Pre-Write Barrier）**，在赋值 后的则叫作**写后屏障（Post-Write Barrier）**。

**使用写屏障可能会带来伪共享问题**，因为现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低。

为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏

```c
if (CARD_TABLE [this address >> 9] != 0)
	CARD_TABLE [this address >> 9] = 0;
```

# 三色标记

三色标记（Tricolor Marking）是一种垃圾回收算法，主要用于标记-清除垃圾回收器中的标记阶段，用于识别和标记活跃对象。这种算法以灰、白、黑三种颜色来表示对象的状态，因此得名“三色标记”。

以下是三色标记算法的基本原理和工作流程：

1. **初始状态**：
   - 所有对象都被标记为白色（White），表示它们尚未被访问或标记。

2. **标记过程**：
   - 从根节点（通常是程序的入口点或全局变量）开始，遍历对象图。
   - 当访问一个对象时，将其标记为灰色（Gray），表示它已经被访问但其引用的对象尚未被标记。
   - 对于灰色对象引用的对象，将它们的状态也标记为灰色，并将它们加入待处理的队列中。

3. **迭代标记**：
   - 重复执行标记过程，直到没有灰色对象为止。这意味着所有可达的对象都被标记为灰色或黑色。

4. **清理阶段**：
   - 在标记结束后，所有未被标记的对象都被认为是不可达的，因此它们被标记为白色。
   - 垃圾回收器可以清理掉所有白色对象，回收它们占用的内存。

5. **黑色对象**：
   - 剩下的所有灰色和黑色对象都被认为是活跃对象，它们将保留在内存中，直到下一次垃圾回收过程。

三色标记算法的关键优势在于它的增量性和并发性。由于标记过程是增量的，可以将它分解成多个小步骤，每一步都能让程序继续执行。这减少了垃圾回收引起的停顿时间。此外，它可以与多线程环境并发执行，因为标记和清理不需要全局停顿，只需保证在标记过程中不改变对象的引用关系即可。

三色标记会存在并发更新的问题，用户线程可能会修改引用关系。这样可能出现两种后果。**一种是把原本消亡的对象错误标记为存活（可以容忍，只会产生浮动垃圾，下一次垃圾回收可以处理），另一种是把原本存活的对象错误标记为已消亡（无法容忍）**

![image-20230908154218357](https://raw.githubusercontent.com/c-ttpfx/markdown-image/main/typora-img/image-20230908154218357.png)

Wilson于1994年在理论上证明了，**当且仅当以下两个条件同时满足时，会产生“对象消失”的问题**，即原本应该是黑色的对象被误标为白色： 

* **赋值器插入了一条或多条从黑色对象到白色对象的新引用；** 
* **赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。**

因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：**增量更新**（Incremental Update）和**原始快照**（Snapshot At The Beginning， SATB）。

**增量更新要破坏的是第一个条件**，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。 

**原始快照要破坏的是第二个条件**，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描 一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。