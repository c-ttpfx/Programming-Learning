# 说明

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。如下图，这篇文章简单介绍下各个区域的作用



![image-20230823011318817](https://raw.githubusercontent.com/c-ttpfx/markdown-image/main/typora-img/image-20230823011318817.png)

# 程序计数器

程序计数器（Program Counter，简称PC）是Java虚拟机（JVM）中的一块内存区域，它是一种较小的、无法被线程切换所影响的内存空间。每个线程都有自己独立的程序计数器，用于存储当前线程执行的字节码指令的地址。

程序计数器在JVM中有以下几个主要作用：

1. **线程控制**：程序计数器指示了每个线程将要执行的指令地址。在线程切换时，JVM能够恢复到正确的执行点。
2. **字节码解释器**：在Java中，代码被编译成字节码（bytecode）。程序计数器用于跟踪当前执行的字节码指令，以便字节码解释器能够逐条执行指令。
3. **异常处理**：当Java程序抛出异常时，JVM会根据异常处理表来确定异常处理代码的位置。程序计数器在这里发挥了关键作用，帮助JVM准确位处理代码的位置。
4. **线程私有**：每个线程都有自己独立的程序计数器。这使得线程能够独立执行，不受其他线程影响。

简单来说程序计数器就是下一条指令要执行的地址，每个线程都会具有，线程私有。

# 虚拟机栈

虚拟机栈（Virtual Machine Stack）是Java虚拟机（JVM）为每个线程私有创建的一块内存区域，用于存储方法执行过程中的局部变量、操作数栈、动态链接和方法出口等信息。每个方法在执行时都会创建一个栈帧（Stack Frame）并入栈，方法执行完毕后栈帧出栈。栈帧包含了方法的局部变量、操作数栈、返回地址等信息。

虚拟机栈具有以下几个主要特点：

1. **线程私有**：每个线程都有自己独立的虚拟机栈，这保证了多线程环境下方法的执行状态不会相互干扰。
2. **方法调用**：虚拟机栈用于保存方法调用的状态。每次方法调用时，会在虚拟机栈上创建一个栈帧，栈帧包含了方法的局部变量、操作数栈等信息。
3. **局部变量和操作数栈**：栈帧内部包含局部变量表和操作数栈。局部变量表用于存储方法中的局部变量，而操作数栈用于执行操作码（字节码指令）时的临时存储。
4. **异常处理**：虚拟机栈也参与异常处理机制。当方法内部发生异常而未被捕获时，虚拟机会查找虚拟机栈来定位异常发生的位置，以便于异常处理。

需要注意的是，虚拟机栈的大小是可以配置的，并且栈空间有可能会发生栈溢出（Stack Overflow）异常。栈溢出通常是由于递归调用深度过大或者局部变量表和操作数栈占用的空间过大导致的。

简单来说每个方法就对应一个栈帧，方法调用和执行就代表了栈帧的出栈和入栈操作，栈帧里面就存放了方法的一些必要信息。

# 本地方法栈

本地方法栈（Native Method Stack）与虚拟机栈类似，是Java虚拟机为执行本地方法（Native Method）而准备的一块内存区域。本地方法指的是用非Java语言（通常是C、C++等）编写的方法，这些方法可以通过Java的本地接口（JNI，Java Native Interface）在Java程序中调用。

本地方法栈是为了支持Java程序与非Java本地方法之间的交互而存在的内存区域，类似于虚拟机栈，但用于本地方法的调用和执行。

# Java堆

当我们在编写Java程序时，所有的对象实例（比如类的实例、数组等）都需要在内存中存储。Java堆就是用来存储这些对象的地方。它是一个非常大的内存区域，被所有线程共享。

关键点如下：

1. **对象存储**：每次使用 `new` 关键字创建一个对象时，这个对象都会被分配到Java堆中。无论是我们自己定义的类，还是Java内置的类，都会在堆上分配内存。

2. **垃圾回收**：Java堆是被垃圾回收器管理的。当一个对象不再被程序引用，也就是没有变量指向它时，垃圾回收器会回收这个对象所占用的内存，以便为将来的对象分配空间。

3. **分代结构**：Java堆通常被划分为不同的“代”，比如新生代和老年代。新创建的对象会被分配到新生代，而存活时间较长的对象会被移到老年代。这种分代结构有助于提高垃圾回收的效率。

4. **内存设置**：我们可以通过命令行参数来设置Java堆的初始大小和最大大小。这可以帮助我们优化程序的内存使用。

5. **内存溢出**：如果我们的程序创建了过多的对象，超过了堆的可用空间，就会引发内存溢出错误，导致程序崩溃。

总之，Java堆是用来存储Java程序中的对象的内存区域，垃圾回收器会在这里管理对象的分配和释放，从而保持程序的正常运行。

# 方法区

方法区（Method Area）是Java虚拟机中的一块内存区域，用于存储类的元数据信息、静态变量、常量池、方法代码等。它是所有线程共享的，与堆一样，也是Java虚拟机的一部分。

以下是关于方法区的一些要点：

1. **元数据信息**：方法区主要用于存储类的元数据信息，包括类的名称、访问修饰符、字段信息、方法信息等。这些信息在运行时被Java虚拟机使用，例如在类加载、字节码解析和方法调用等时候。

2. **静态变量**：静态变量，也叫类变量，被存储在方法区中。这些变量在类加载的过程中被创建并分配内存，它们在整个类的生命周期内保持不变。

3. **常量池**：常量池是一种存储在方法区中的数据结构，用于存放编译时生成的各种字面量和符号引用。它包括字符串常量、类和接口的全限定名、字段和方法的名称和描述符等信息。

4. **方法代码**：方法区也存储类的方法代码。这些代码在类被调用时被执行。方法区中存储的方法字节码被解释器或者即时编译器（如HotSpot的C2编译器）执行。

5. **运行时常量池**：在Java 7 及之前的版本，常量池也包括一部分运行时生成的常量。但从Java 8 开始，运行时常量池已经被移到堆中的一部分，称为运行时常量池。

6. **内存溢出**：方法区内存溢出错误通常被称为“永久代溢出”，这是因为在Java 7 及之前的版本中，方法区被实现为持久代。随着类加载和卸载的不断进行，方法区的空间也会被耗尽，导致程序崩溃。

需要注意的是，从Java 8 开始，方法区被元空间（Metaspace）所取代。元空间使用的是本地内存而非虚拟机内存，因此它更加灵活，避免了持久代溢出等问题。

总之，方法区是存储类的元数据、静态变量、常量池和方法代码等信息的内存区域，是Java虚拟机重要的组成部分之一。

# 运行时常量池

当Java类文件被加载到内存中时，会创建一个运行时常量池（Runtime Constant Pool），它是类中常量的一种运行时表示。运行时常量池包含了从类文件的编译时常量池中提取出来的一部分内容，以及在运行时生成的常量。

编译时常量池是位于类文件中的，它包含了类中的各种常量，如字符串、数字、类名、方法名等。而运行时常量池是在类加载时被构建的，用于在程序运行期间支持常量的引用和操作。

运行时常量池不仅包含编译时常量池中的内容，还可能包括一些在运行时生成的常量。例如，字符串拼接的结果、动态方法调用等都可以在运行时常量池中得到体现。

需要注意的是，从Java 8 开始，常量池被移到元空间（Metaspace）中，取代了之前的永久代。元空间具有更大的灵活性，不再受到固定大小的限制。在这种情况下，运行时常量池仍然存在，但它与常量池的管理方式有所不同。

总之，运行时常量池是在类加载后构建的一种数据结构，包含了编译时常量池中的部分内容以及在运行时生成的常量，它为Java程序提供了常量引用和操作的支持。

# 直接内存

当我们在Java程序中使用内存时，通常会涉及到Java堆内存、栈内存等。而直接内存是一种与传统内存管理方式不同的内存分配方式，主要用于提高I/O操作的性能和效率。直接内存是一种用于提高I/O操作性能的内存分配方式，在Java NIO库中得到广泛应用。虽然它可以提供一些性能优势，但需要开发者自行管理分配和释放，以避免潜在的风险。

传统的Java内存管理方式中，Java堆内存的分配和释放都由JVM的垃圾回收机制进行管理。但是在一些特定场景下，特别是涉及到I/O操作的时候，传统的内存管理方式可能会导致性能问题。这时，直接内存可以作为一个媒介，充当了Java程序和操作系统之间的桥梁，以提高性能和效率。

传统的Java堆内存分配方式涉及以下步骤：

1. **应用程序到Java堆内存的拷贝**：当数据从应用程序传递到Java堆内存时，需要进行数据拷贝。
2. **Java堆内存到操作系统的拷贝**：当执行I/O操作时，数据需要从Java堆内存复制到操作系统的内核缓冲区。
3. **操作系统到Java堆内存的拷贝**：I/O操作完成后，数据又需要从操作系统的内核缓冲区复制回Java堆内存。

而使用直接内存的情况下：

1. **应用程序到直接内存的拷贝**：当数据从应用程序传递到直接内存时，不需要进行数据拷贝，数据直接存储在直接内存中。
2. **直接内存到操作系统的拷贝**：当执行I/O操作时，数据可以直接从直接内存传递给操作系统的内核缓冲区，避免了数据复制。
3. **操作系统到直接内存的拷贝**：I/O操作完成后，数据可以直接从操作系统的内核缓冲区传递回直接内存，同样避免了数据复制。

总之，使用直接内存可以减少数据在内存之间的复制，从而提高I/O操作的性能。这种方式特别适用于需要频繁进行大量I/O操作的场景，例如文件读写、网络传输等。然而，需要注意的是，直接内存的管理需要开发者自行负责，如果管理不当，可能会导致内存泄漏和其他问题。